/**
 * Scans the ex folder (brand folders with product images) and generates
 * src/data/exProducts.ts. Run from project root: node scripts/buildExProducts.mjs
 * Expects ex folder at ../../ex relative to this script (workspace root/ex).
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.join(__dirname, '..');
const exRoot = path.join(projectRoot, '..', '..', 'ex');
const publicDir = path.join(projectRoot, 'public');
const publicExDir = path.join(publicDir, 'ex');
const outputPath = path.join(projectRoot, 'src', 'data', 'exProducts.ts');

// Map ex folder name (as on disk) to brand name (as in brands.ts)
const FOLDER_TO_BRAND_NAME = {
  'Always': 'Always',
  'Beauty of Joseon': 'BEAUTY OF JOSEON',
  'Duzzit': 'Duzzit',
  'Elbow Grease': 'Elbow Grease',
  'HomeMaid': 'Home Maid',
  'KOSE': 'KOSE',
  'LimeAway': 'Lime Away',
  'medicube': 'medicube',
  'Nestle': 'Nestle',
  'Oven Brite': 'Oven Brite',
  'PURITO': 'Purito SEOUL',
  'Swirl': 'Swirl',
  'TASSIMO': 'Tassimo',
};

function getBrandSlug(name) {
  return name
    .toLowerCase()
    .replace(/\s*&\s*/g, '-')
    .replace(/\s+/g, '-')
    .replace(/['']/g, '')
    .replace(/é/g, 'e')
    .replace(/[^a-z0-9-]/g, '');
}

// EAN-13: last digit is check. Weights 1,3,1,3... from first 12 digits.
function randomEAN13() {
  const digits = Array.from({ length: 12 }, () => Math.floor(Math.random() * 10));
  const sum = digits.reduce((s, d, i) => s + d * (i % 2 === 0 ? 1 : 3), 0);
  const check = (10 - (sum % 10)) % 10;
  return digits.join('') + check;
}

// Specific EANs for Beauty of Joseon: (2 Pack) 08809782558905, (1 Pack) 8809782555508
function getEanForProduct(brandName, title) {
  if (brandName === 'BEAUTY OF JOSEON') {
    if (title.includes('Pack of 2')) return '08809782558905';
    if (title.includes('50ml') && !title.includes('Pack of 2')) return '8809782555508';
  }
  return randomEAN13();
}

if (!fs.existsSync(exRoot)) {
  console.error('ex folder not found at:', exRoot);
  process.exit(1);
}

const productsByBrandSlug = {};
const exBrandSlugs = [];
const allProducts = [];

const dirs = fs.readdirSync(exRoot, { withFileTypes: true }).filter(d => d.isDirectory());

for (const dir of dirs) {
  const folderName = dir.name;
  const brandName = FOLDER_TO_BRAND_NAME[folderName];
  if (!brandName) {
    console.warn('Skipping unknown brand folder:', folderName);
    continue;
  }

  const slug = getBrandSlug(brandName);
  const brandPath = path.join(exRoot, folderName);
  const files = fs.readdirSync(brandPath).filter(f => /\.(png|jpg|jpeg|webp)$/i.test(f));

  const products = files.map(file => {
    const title = file.replace(/\.(png|jpg|jpeg|webp)$/i, '');
    // Store path with encoded segments so it works as img src; files on disk keep original names
    const imagePath = `/ex/${encodeURIComponent(folderName)}/${encodeURIComponent(file)}`;
    const ean = getEanForProduct(brandName, title);
    return { title, image: imagePath, ean };
  });

  if (products.length > 0) {
    productsByBrandSlug[slug] = { brandName, products };
    exBrandSlugs.push(slug);
    products.forEach(p => allProducts.push({ brandSlug: slug, brandName, title: p.title, image: p.image, ean: p.ean }));
  }
}

// Copy ex folder to public/ex so images are served
if (!fs.existsSync(publicDir)) fs.mkdirSync(publicDir, { recursive: true });
if (fs.existsSync(publicExDir)) {
  fs.rmSync(publicExDir, { recursive: true });
}
copyDirSync(exRoot, publicExDir);

function copyDirSync(src, dest) {
  fs.mkdirSync(dest, { recursive: true });
  for (const entry of fs.readdirSync(src, { withFileTypes: true })) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirSync(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

const tsContent = `// Auto-generated by scripts/buildExProducts.mjs – do not edit by hand.
// Product data from ex folder; images are served from /ex/...

export const exBrandSlugs: string[] = ${JSON.stringify(exBrandSlugs)};

export interface ExProduct {
  title: string;
  image: string;
  ean: string;
}

export const productsByBrandSlug: Record<string, { brandName: string; products: ExProduct[] }> = ${JSON.stringify(
  Object.fromEntries(
    Object.entries(productsByBrandSlug).map(([slug, { brandName, products }]) => [
      slug,
      { brandName, products: products.map(({ title, image, ean }) => ({ title, image, ean })) },
    ])
  ),
  null,
 2
)};

/** All products flattened for search: brandSlug, brandName, title, image, ean */
export const allProductsForSearch: Array<{ brandSlug: string; brandName: string; title: string; image: string; ean: string }> = ${JSON.stringify(allProducts)};
`;

fs.writeFileSync(outputPath, tsContent, 'utf8');
console.log('Generated', outputPath);
console.log('Copied ex to public/ex');
console.log('Brands in ex:', exBrandSlugs.length);
console.log('Total products:', allProducts.length);
